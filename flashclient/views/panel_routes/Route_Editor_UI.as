/* Copyright (c) 2006-2010 Regents of the University of Minnesota.
   For licensing terms, see the file LICENSE. */

// MAYBE: This class is used via static methods. Ideally, this should be part
//        of, maybe, Panel_Item_Route, or Find_Route_Manager (G.tabs.route),
//        and then this class would use this.route_panel.route instead of
//        G.item_mgr.active_route.

package views.panel_routes {

   import flash.display.Graphics;
   import flash.display.Sprite;
   import flash.events.Event;
   import flash.events.MouseEvent;
   import flash.events.TimerEvent;
   import flash.filters.ColorMatrixFilter;
   import flash.utils.Timer;
   import mx.collections.ArrayList;
   import mx.managers.PopUpManager;

   import gwis.GWIS_Base;
   import gwis.GWIS_Geocode;
   import gwis.GWIS_Route_Get_New;
   import items.Geofeature;
   import items.feats.Route;
   import items.feats.Route_Step;
   import items.utils.Travel_Mode;
   import utils.geom.Geometry;
   import utils.misc.Introspect;
   import utils.misc.Logging;
   import views.base.UI;
   import views.commands.Route_Path_Edit_Command;
   import views.panel_routes.Route_Stop_Editor;

   /*
    * NOTE + WARNING:
    * This code works only with routes generated by routed_v1 because it
    * requires all-bicycle route steps, with valid node ids.
    *
    * Theoretically, with the negative ids that routed_v2 uses for transit
    * steps, most of this code should function unmodified. However, there is
    * still a lot of work needed to properly handle the time information
    * associated with transit stops.
    *
    * So for now, most of the functions contain asserts preventing a
    * multimodal (MM) route from being edited.
    */
   public class Route_Editor_UI {

      // *** Class attributes

      protected static var log:Logging = Logging.get_logger('@Rt_Edit_UI');

      public static var stale:Boolean;

      public static var new_stop:Route_Stop;

      protected static var update_timer:Timer
         = new Timer(Conf.route_path_update_delay, 1);

      // 2013.12.14: [lb] doesn't like this timer. As the user drags a route,
      // if they pause while holding the mouse down, we'll compute an
      // intermediate route. But calculating a route takes a while, and it
      // feels disruptive -- a user's mental model is to just click, drag,
      // and release, so the intermediate route computation feels clunky.
      // Also, like I said, calculating a route takes the server a while,
      // so just wait for the user to release the mouse.
      //protected static var use_update_timer:Boolean = true;
      public static var use_update_timer:Boolean = false;

      // *** Static instance methods

      // FIXME: Statewide UI: This whole class is static. But we support
      //        multiple route detail panels. Using G.item_mgr.active_route
      //        is probably okay for now, but we should de-staticfy this
      //        class. We could have the Find_Route_Manager make this objects
      //        (G.tabs.route). See comments above.

      //
      public static function cancel_destination_add() :void
      {
         m4_DEBUG('cancel_destination_add');

         // This fcn. is called when user clicks "Cancel" after had previously
         // clicked "Add Destination", or if user hits escape while dragging.

         var route:Route;

         if (Route_Editor_UI.new_stop !== null) {

            m4_DEBUG2('cancel_destination_add: new_stop:',
                      Route_Editor_UI.new_stop);

            // If we're stopping editing before the user chose an option
            // for the route_stop we will just remove it.
            var wp:ArrayList = new ArrayList(
               Route_Editor_UI.new_stop.route.edit_stops);
            var i:int = Route_Editor_UI.new_stop.route.edit_stops.indexOf(
                                                Route_Editor_UI.new_stop);
            if (i >= 0) {
               wp.removeItemAt(i);
               Route_Editor_UI.new_stop.route.edit_stops_set(wp.source);
               if (Route_Editor_UI.new_stop.parent !== null) {
                  Route_Editor_UI.new_stop.parent.removeChild(
                     Route_Editor_UI.new_stop);
               }
            }

            route = Route_Editor_UI.new_stop.route;

            Route_Editor_UI.new_stop = null;

            G.map.tool_choose('tools_pan');
         }

         if (G.map.tool_cur.dragged_object is Route_Stop) {
            m4_DEBUG('cancel_destination_add: dragged_object is Route_Stop');

            var route2:Route;
            route2 = (G.map.tool_cur.dragged_object as Route_Stop).route;

            m4_ASSERT_SOFT((route === null) || (route === route2));
            route = route2;
         }

         if (route !== null) {
            m4_DEBUG('cancel_destination_add: disable_rstop_editing:', route);

            route.disable_rstop_editing();
         }
      }

      //
      public static function notify_stop_changed(rt_stop:Route_Stop,
                                                 timed:Boolean=false) :void
      {
         m4_DEBUG('notify_stop_changed: rstop:', rt_stop);

         m4_ASSERT_SOFT(!rt_stop.route.is_multimodal);

         // Skipping: x_map, y_map, name_, node_id, version
         //           is_endpoint
         //           is_pass_through
         //           is_transit_stop
         //           internal_system_id
         //           external_result
         //           is_arrive
         rt_stop.street_name_ = null;
         m4_TALKY('notify_stop_changed: bump vers: rt_stop:', rt_stop);
         rt_stop.stop_version += 1;
         rt_stop.dirty_stop = true;
         // Skipping: orig_stop

         rt_stop.route.draw();

         // restart autoupdate timer, maybe
         if (timed) {
            m4_DEBUG('notify_stop_changed: resetting update_timer');
            Route_Editor_UI.update_timer.reset();
            Route_Editor_UI.update_timer.start();
         }
         else {
            // update right away
            m4_DEBUG('notify_stop_changed: route_update');
            Route_Editor_UI.route_update(rt_stop.route);
         }
      }

      //
      protected static function on_update_timer_event(t:TimerEvent) :void
      {
         var rt:Route = null;
         if (G.map.selectedset.length > 0) {
            // rt = (G.map.selectedset.item_get_random() as Route);
            rt = G.item_mgr.active_route;
            if (rt !== null) {
               if (rt.hydrated) {
                  if (Route_Editor_UI.use_update_timer) {
                     m4_DEBUG('on_update_timer_event: route_update');
                     Route_Editor_UI.route_update(rt);
                  }
                  else {
                     m4_DEBUG('on_update_timer_event: skipping timer event');
                  }
               }
               else {
                  m4_DEBUG('on_update_timer_event: waiting lazy load');
               }
            }
         }
         if (rt === null) {
            // The route is no longer selected. Route.selected should
            // deregister the event, so this shouldn't happen.
            m4_ASSERT_SOFT(false);
         }
      }

      //
      public static function route_destination_add(rt:Route) :void
      {
         // Called when user clicks "Add Destination" in details panel.

         var newpt:Route_Stop;

         // BUG nnnn: How is the 26-limit route destinations enforced?
         //           It seems silly this limit is merely because we label
         //           route stops with letters of the alphabet.
         //m4_ASSERT(rt.num_dests < 26);
         ////m4_ASSERT(rt.num_dests < Strutil.letters_uc.length);
         // UPDATE: [lb] wrote a Strutil that wraps around from 'z' to 'aa',
         // etc... so it'll just get wider with every 26 chars.

         m4_ASSERT_SOFT(!rt.is_multimodal);

         var rt_stop_obj:Route_Stop_Editor = null;
         var is_pass_through:Boolean = false;
         m4_ASSERT_SOFT(rt.master_route === null);
         m4_ASSERT_SOFT(rt.master_item === null);
         newpt = new Route_Stop(rt, rt_stop_obj, is_pass_through);
         newpt.node_id = 0;
         newpt.stop_version = 0;
         // Set via edit_stops_push: newpt.is_endpoint
         // Set via ctor: newpt.is_pass_through
         newpt.is_transit_stop = false;
         newpt.internal_system_id = 0;
         newpt.external_result = false;
         newpt.street_name_ = null;
         newpt.dirty_stop = true;
         Route_Editor_UI.new_stop = newpt;
         // The rt can be null if it's used by the Find Route panel.
         if (rt !== null) {
            rt.edit_stops_push(newpt);
         }

         m4_DEBUG('route_destination_add: choosing route stop tool');
         G.map.tool_choose('tools_route_dest_add');
      }

      //
      public static function route_edit_start() :void
      {
         m4_DEBUG('route_edit_start: starting on_update_timer_event');
         Route_Editor_UI.update_timer.addEventListener(TimerEvent.TIMER,
                                                       on_update_timer_event,
                                                       false, 0, true);
      }

      //
      public static function route_edit_stop() :void
      {
         m4_DEBUG('route_edit_stop: stopping on_update_timer_event');
         Route_Editor_UI.update_timer.removeEventListener(TimerEvent.TIMER,
                                                      on_update_timer_event);
         if (Route_Editor_UI.update_timer.running) {
            Route_Editor_UI.update_timer.stop();
         }
         Route_Editor_UI.cancel_destination_add();
      }

      //
      public static function route_segment_fetch(seg:Route_Segment) :void
      {
         // MAYBE: Use prefs in seg.ref_route, or tell server to use orig
         //        route's planner options. Or is using the find route
         //        panel's settings the best idea?
         var preferences:XML = G.user.rf_prefs_xml();

         var gwis_req:GWIS_Route_Get_New;
         gwis_req = new GWIS_Route_Get_New(

            seg.lhs_rstop.name_,
            seg.lhs_rstop.x_map,
            seg.lhs_rstop.y_map,

            seg.rhs_rstop.name_,
            seg.rhs_rstop.x_map,
            seg.rhs_rstop.y_map,

            /*caller_source=*/'editor',

            /*callback_okay=*/Route_Editor_UI.route_segment_fetch_callback,
            /*callback_fail=*/Route_Editor_UI.route_segment_fetch_failure,
            /*callback_obj=*/seg,

            preferences,

            /*ref_route=*/seg.ref_route,
            /*dont_save=*/true,
            /*compute_landmarks=*/seg.ref_route.show_landmarks,

            // FIXME: Shouldn't we fetch using the route's original finder
            //        values? Other using the new route panel's settings?
            //        The latter kind of makes sense, except the user won't
            //        necessarily know that the options they've got set on
            //        another panel affect the route as they drag it around
            //        the map...
            //
            //  /*travel_mode=*/Travel_Mode.wayward,
            //  /*travel_mode=*/seg.ref_route.travel_mode,
            /*travel_mode=*/G.app.routes_panel.routes_new.travel_mode,
            /*p2_depart_at=*/'',
            /*p2_transit_pref=*/0
            );

         gwis_req.fetch();
      }

      //
      public static function route_segment_fetch_callback(
         gwis_req:GWIS_Route_Get_New, route:Route) :void
      {
         m4_DEBUG('route_seg_fetch_cb: seg route:', route);
         m4_DEBUG2('route_seg_fetch_cb: ref_route:',
                   gwis_req.ref_route);

         var seg:Route_Segment = gwis_req.callback_obj;

         if (route !== null) {
            m4_ASSERT_SOFT(seg.ref_route === gwis_req.ref_route);
            seg.seg_route = route;
            //seg.lhs_rstop
            //seg.rhs_rstop
            seg.xs = route.xs;
            seg.ys = route.ys;
            seg.seg_rsteps = route.rsteps;
            seg.seg_rstops = route.rstops;
            // 2014.09.13: Finish Implementing: rsn_len and avg_cost.
            seg.rsn_len = route.rsn_len;
            seg.avg_cost = route.avg_cost;
            //seg.seg_error
            //seg.lhs_version
            //seg.rhs_version
            m4_DEBUG('route_seg_fetch_cb: dispatchEvent: routeStepsLoaded');
            seg.ref_route.dispatchEvent(new Event('routeStepsLoaded'));
            // And now we can let item be discarded...
         }
         else {
            m4_ASSERT_SOFT(false); // The fail fcn. should be called instead.
            seg.seg_error = true;
         }
      }

      //
      public static function route_segment_fetch_failure(
         gwis_req:GWIS_Route_Get_New, rset:XML) :void
      {
         m4_DEBUG('route_seg_fetch_fail: gwis_req:', gwis_req);

         var seg:Route_Segment = gwis_req.callback_obj;
         seg.seg_error = true;

         m4_DEBUG('route_seg_fetch_fail: dispatchEvent: routeStepsLoaded');
         seg.ref_route.dispatchEvent(new Event('routeStepsLoaded'));
      }

      //
      public static function route_stop_insert(
         rt:Route,
         x_map:Number,
         y_map:Number)
            :Route_Stop
      {
         m4_ASSERT_SOFT(!rt.is_multimodal);

         var index:int;
         var new_rt_stop:Route_Stop;
         var ls:ArrayList = new ArrayList(rt.edit_stops);

         m4_DEBUG('route_stop_insert: rt:', rt);

         if (rt.edit_stops.length <= 1) {
            // The new route_stop will have an index equal to the length.
            index = rt.edit_stops.length;
         }
         else {
            // Search for the index between two existing route stops.
            // that (x, y) are closest to.
            index = Route_Editor_UI.rstop_index_search(rt, x_map, y_map);
         }

         // Now that we have an index, insert a new route_stop at the index.
         var rt_stop_obj:Route_Stop_Editor = null;
         var is_pass_through:Boolean = true;
         m4_ASSERT_SOFT(rt.master_route === null);
         m4_ASSERT_SOFT(rt.master_item === null);
         new_rt_stop = new Route_Stop(rt, rt_stop_obj, is_pass_through);
         new_rt_stop.name_ = null;
         new_rt_stop.node_id = 0;
         new_rt_stop.stop_version = 0;
         new_rt_stop.x_map = x_map;
         new_rt_stop.y_map = y_map;
         // Set via edit_stops_set: new_rt_stop.is_endpoint
         // Set via ctor: new_rt_stop.is_pass_through
         new_rt_stop.is_transit_stop = false;
         new_rt_stop.internal_system_id = 0;
         new_rt_stop.external_result = false;
         new_rt_stop.street_name_ = null;

         m4_DEBUG('route_stop_insert: i:', index, '/', new_rt_stop);
         ls.addItemAt(new_rt_stop, index);
         rt.edit_stops_set(ls.source);

         Route_Editor_UI.notify_stop_changed(new_rt_stop, true);
         new_rt_stop.dirty_stop = true;

         return new_rt_stop;
      }

      //
      public static function route_stop_remove(rt_stop:Route_Stop) :void
      {
         var rt:Route = rt_stop.route;
         var rstops:ArrayList = new ArrayList(rt.edit_stops);
         var stop_index:int = rt.edit_stops.indexOf(rt_stop);

         m4_DEBUG('route_stop_remove: rt:', rt);

         m4_ASSERT_SOFT(!rt.is_multimodal);

         m4_ASSERT_SOFT((rt_stop.is_pass_through)
                        || (rt_stop.stop_version == 0)
                        || (rt.num_dests > 2));

         if (stop_index >= 0) {

            m4_DEBUG('route_stop_remove: i:', stop_index, '/', rt_stop);

            rstops.removeItemAt(stop_index);
            rt.edit_stops_set(rstops.source);

            if (rt_stop.parent !== null) {
               rt_stop.parent.removeChild(rt_stop);
            }

            m4_TALKY('route_stop_remove: bump vers: rt_stop:', rt_stop);
            rt_stop.stop_version += 1;
            rt_stop.dirty_stop = true;
            //rt_stop.route.draw();

            Route_Editor_UI.route_update(rt_stop.route);
         }
      }

      //
      public static function route_update(rt:Route) :void
      {
         m4_ASSERT_SOFT(!rt.is_multimodal);

         m4_DEBUG('route_update: route:', rt.softstr);

         var rt_stop:Route_Stop;
         for each (rt_stop in rt.edit_stops) {
            // 2014.05.07: Old CcpV1 comment and code:
            //    // route_update() will be called again when the geocode
            //    // completes so we can just return now
            //    if (rt_stop.geocode_pending) {
            //       return;
            //    }
            // except geocode_pending hasn't been wired (ever set true) in a
            // while, so that return hasn't been executing. And things seem
            // fine. Nonetheless, [lb] is curious if we do sometimes come
            // through here: we're more deliberate about calling route_update,
            // so I'd think... not?
            m4_ASSERT_SOFT(rt_stop.gwis_geocode === null);
         }

         var cmd:Route_Path_Edit_Command = new Route_Path_Edit_Command(rt);
         // CcpV1 would add to map's command stack: G.map.cm.do_(cmd).
         // But now we manage a command stack for each route.
         rt.route_panel.cmd_mgr.do_(cmd);

         G.panel_mgr.panel_activate(rt.route_panel);

         m4_DEBUG3('route_update: new Route_Path_Edit_Command:', cmd,
                   'tool_cur.dragging:', G.map.tool_cur.dragging,
                   'tool_cur.dragged_object:', G.map.tool_cur.dragged_object);

         m4_ASSERT_SOFT(cmd.is_prepared !== null);
      }

      //
      public static function route_update_complete(rt:Route,
                                                   segments:Array,
                                                   ignore_version:Boolean)
         :Boolean
      {
         // The wait_for_it indicates if the caller needs to call us again once
         // the route's rsteps load.
         var wait_for_it:Boolean = false;

         // check to see how many segments have completed loading
         m4_ASSERT_SOFT(!rt.is_multimodal);

         m4_DEBUG_CLLL('<callLater: route_update_complete: rt');
         m4_DEBUG('route_update_complete: rt:', rt.softstr);

         m4_DEBUG2('route_update_complete: segments.len:',
                   (segments !== null) ? segments.length : 'none');
         m4_DEBUG('route_update_complete: segments:', segments);

         if ((rt.updating_segments !== null)
             && (segments === rt.updating_segments)) {
            wait_for_it = Route_Editor_UI.route_update_complete_(
                                    rt, segments, ignore_version);
         }
         else {
            m4_DEBUG('route_update_complete: user stopped editing');
         }

         return wait_for_it;
      }

      //
      protected static function route_update_complete_(rt:Route,
                                                       segments:Array,
                                                       ignore_version:Boolean)
         :Boolean
      {
         var wait_for_it:Boolean = false;
         var loaded_ok:Boolean = true;
         var num_loaded:int = 0;
         var error_text:String;

         for each (var seg:Route_Segment in segments) {
            m4_DEBUG('route_update_complete_: seg:', seg);
            m4_DEBUG('route_update_complete_: seg.lhs_rstop:', seg.lhs_rstop);
            m4_DEBUG('route_update_complete_: seg.rhs_rstop:', seg.rhs_rstop);
            if ((!ignore_version)
                && (   (seg.lhs_version != seg.lhs_rstop.stop_version)
                    || (seg.rhs_version != seg.rhs_rstop.stop_version)
                    || (   rt.edit_stops.indexOf(seg.rhs_rstop)
                        != rt.edit_stops.indexOf(seg.lhs_rstop) + 1))) {
               // The route_stops for the route have been moved, removed, or
               // had another route_stop inserted between them making the
               // segment invalid, so cancel this update.
               m4_DEBUG('route_update_complete_: route_stops changd; bailing');
               // 2014.05.07: Okay, seriously, this smells like a CcpV1 hack
               // because the old code didn't cancel outstanding GWIS commands.
               // In CcpV2, if we start a route request and then someone edits
               // the route again before the request completes, we'll cancel
               // the outstanding request... right?

               // 2014.09.09: FIRING:
               m4_ASSERT_SOFT(false);
               // This might not be of concern:
               //  TEST: Drag route, and while get-route outstanding,
               //        drag route again. Does that cause this code
               //        to run? I.e., we're just canceling a route
               //        calculcation because the user re-dragged the
               //        route?
               G.sl.event('error/rte_editor_ui/route_update_complete_',
                          {route: rt});

               loaded_ok = false;
               break;
            }
            else if (seg.seg_error) {
               // In CcpV1, this could happen for problems trying to route
               // between network islands, i.e., endpoints are in distinct
               // trees of the graph. But in CcpV2, this shouldn't happen,
               // unless maybe the user drags a waypoint so far away from
               // our bbox that we don't find a nearby byway and endpoint.
               // And we've already alerted the user to the problem, via
               // GWIS_Route_Get_new.error_present.
               // MAYBE: Do we need to undo the user's route stop drag?
               m4_DEBUG('route_update_complete_: cannot update route');
               loaded_ok = false;
               break;
            }
            else if (seg.seg_rsteps !== null) {
               // The route_step has just been loaded or was loaded previously,
               // and its segment did not fail or become invalid by route_stop
               // editing.
               num_loaded++;
               m4_DEBUG('route_update_complete_: n/a: numLoaded:', num_loaded);
            }
            else {
               // This step (well, sub-Route, I guess [lb]), is still being
               // loaded. We'll hook the rstepsLoadedEvent later.
               m4_DEBUG('route_update_complete_: wait: still loading');
            }
         }

         m4_DEBUG2('route_update_complete_: loaded_ok:', loaded_ok,
                   '/ num_loaded:', num_loaded);

         if (loaded_ok) {

            if (num_loaded == segments.length) {

               // Everything loaded okay / is loaded now.
               Route_Editor_UI.stale = false;
               rt.updating_segments = null;

               // We've historically set this here but it gets set again by the
               // route panel or something.
               G.app.item_navver.nav_panel_title.htmlText
                  = 'About the Selected Route';

               // Stitch the segments together: the user dragged or placed a
               // route stop, so splice the new route sub-segment into the
               // route. ([lb] guesses 'splice' is synonymous with 'stitch'
               // in this context.)
               Route_Editor_UI.route_update_stitch(rt, segments);

               // We're all done updating so nix our listener.
               //   G.item_mgr.removeEventListener('routeStepsLoaded',
               //                                  this.on_rsteps_loaded);

               // Tell the Route panel its dirty so that the route details are
               // updated to reflect the new length and route stops, and so the
               // directions tab shows the new directions.
               m4_DEBUG('route_update_complete_: panels_mark_dirty: rte pnl');
               rt.mark_route_panel_dirty();
            }
            else {

               // We're still waiting on one or more sub-routes to load.
               var percent:int = int(
                  (Number(num_loaded) / Number(segments.length)) * 100.0);
               // MAYBE: This belongs elsewhere. The route panel could handle
               //        it. See: panel_title_get

               // FIXME: Revisit this: It looks funny, and it stops updating
               //        sometimes. Can we put a throbberer widget inline
               //        in the route destinations list?
               G.app.item_navver.nav_panel_title.htmlText =
                  ('Route Details (updating...' + percent + '%)');

               // 2013.04.30: This is Bad Form. This fcn. used to callLater
               // itself over and over until all routes were loaded from the
               // server or until their rsteps were otherwise set. But that's
               // lazy; even calling this fcn. again every second rather than
               // immediately is a better, albeit still lazy, solution. Really,
               // we should wait for an event to happen instead.
               //   m4_DEBUG_CLLL('>callLater: route_update_complete: same');
               //   G.map.callLater(Route_Editor_UI.route_update_complete,
               //                   [rt, segments, ignore_version]);
               // This is Better Form: tell the caller to use addEventListener:
               //   G.item_mgr.addEventListener('routeStepsLoaded',
               //                               this.on_rsteps_loaded);
               wait_for_it = true;
            }
         }
         else {
            // !loaded_ok.
            m4_ASSERT_SOFT(!wait_for_it);
            G.app.item_navver.nav_panel_title.htmlText
               = 'About the Selected Route';
         }

         return wait_for_it;
      }

      //
      protected static function route_update_stitch(rt:Route, segments:Array)
         :void
      {
         // NOTE: segments is what was rt.updating_segments, which is
         //       Route_Path_Edit_Command's new_segments, which is a
         //       collection of Route_Segment objects.

         m4_DEBUG('rte_upd_stitch: segs.len:', segments.length, '/ rt:', rt);

         var new_rsn_len:Number = 0.0;

         var first_segment:Boolean = true;

         var new_xs:Array = new Array();
         var new_ys:Array = new Array();
         var new_steps:Array = new Array();
         var new_stops:Array = new Array();

         for each (var seg:Route_Segment in segments) {

            m4_DEBUG2('rte_upd_stitch: seg.seg_rsteps.len:',
                      seg.seg_rsteps.length);

            if (seg.seg_rsteps.length == 0) {
               // BUG nnnn/FIXME: [lb] sees this problem with some routes, like
               //                 1593749 ("8170 St Paul Loop"): C & D are same
               //                 x,y, it appears, so maybe there is a seg with
               //                 no steps?
               m4_WARNING('rte_upd_stitch: no seg rsteps:', seg, '/ rt:', rt);
               m4_ASSERT_SOFT(false);
               continue;
            }

            var curr_step:Route_Step;
            var rs_editor:Route_Stop_Editor;

            if (first_segment) {
               // Add first route_stop.
               curr_step = seg.seg_rsteps[0];

               rs_editor = new Route_Stop_Editor();
               rs_editor.name_ = seg.lhs_rstop.name_;
               rs_editor.node_id = (curr_step.forward
                                    ? curr_step.beg_node_id
                                    : curr_step.fin_node_id);
               m4_ASSERT_SOFT(rs_editor.node_id > 0);
               rs_editor.stop_version = seg.lhs_rstop.stop_version;
               rs_editor.x_map = seg.xs[curr_step.beg_index];
               rs_editor.y_map = seg.ys[curr_step.beg_index];
               rs_editor.is_endpoint = seg.lhs_rstop.is_endpoint;
               rs_editor.is_pass_through = seg.lhs_rstop.is_pass_through;
               rs_editor.is_transit_stop = seg.lhs_rstop.is_transit_stop;
               rs_editor.internal_system_id = seg.lhs_rstop.internal_system_id;
               rs_editor.external_result = seg.lhs_rstop.external_result;
               rs_editor.street_name_ = null; // seg.lhs_rstop.street_name_,
               rs_editor.editor = seg.lhs_rstop;
               new_stops.push(rs_editor);
            }

            // Always add the last step as a route_stop.
            curr_step = seg.seg_rsteps[seg.seg_rsteps.length - 1];
            m4_DEBUG('rte_upd_stitch: seg.seg_rsteps[-1]:', curr_step);
            rs_editor = new Route_Stop_Editor();
            rs_editor.name_ = seg.rhs_rstop.name_;
            rs_editor.node_id = (curr_step.forward
                                 ? curr_step.fin_node_id
                                 : curr_step.beg_node_id);
            m4_ASSERT_SOFT(rs_editor.node_id > 0);
            rs_editor.x_map = seg.xs[curr_step.fin_index - 1];
            rs_editor.y_map = seg.ys[curr_step.fin_index - 1];
            rs_editor.stop_version = seg.rhs_rstop.stop_version;
            rs_editor.is_endpoint = seg.rhs_rstop.is_endpoint;
            rs_editor.is_pass_through = seg.rhs_rstop.is_pass_through;
            rs_editor.is_transit_stop = seg.rhs_rstop.is_transit_stop;
            rs_editor.internal_system_id = seg.rhs_rstop.internal_system_id;
            rs_editor.external_result = seg.rhs_rstop.external_result;
            rs_editor.street_name_ = null; // seg.rhs_rstop.street_name_,
            rs_editor.editor = seg.rhs_rstop;
            new_stops.push(rs_editor);

            var first_step:Boolean = true;
            for each (curr_step in seg.seg_rsteps) {
               // clone properties of the route step
               var new_step:Route_Step = new Route_Step();
               new_step.step_name = curr_step.step_name;
               new_step.travel_mode = curr_step.travel_mode;
               new_step.byway_geofeature_layer_id
                  = curr_step.byway_geofeature_layer_id;
               new_step.byway_stack_id = curr_step.byway_stack_id;
               new_step.byway_version = curr_step.byway_version;

               new_step.forward = curr_step.forward;
               new_step.beg_node_id = curr_step.beg_node_id;
               new_step.fin_node_id = curr_step.fin_node_id;
               m4_TALKY2('rte_upd_stitch: beg_node_id / fin_node_id:',
                         new_step.beg_node_id, '/', new_step.fin_node_id);
               new_step.node_lhs_elevation_m = curr_step.node_lhs_elevation_m;
               new_step.node_rhs_elevation_m = curr_step.node_rhs_elevation_m;
               new_step.step_length = curr_step.step_length;
               new_step.rating = curr_step.rating;
               new_step.bonus_tagged = curr_step.bonus_tagged;
               new_step.penalty_tagged = curr_step.penalty_tagged;

               new_step.beg_index = new_xs.length;

               var i:int
               for (i = curr_step.beg_index; i < curr_step.fin_index; i++) {
                  if ((!first_segment)
                      && (first_step)
                      && (i == curr_step.beg_index)) {
                     // share ending vertex from last segment
                     new_step.beg_index--;
                     continue;
                  }
                  new_xs.push(seg.xs[i]);
                  new_ys.push(seg.ys[i]);
               }

               new_step.fin_index = new_xs.length;
               new_steps.push(new_step);
               new_rsn_len += new_step.step_length;
               first_step = false;
            }

            first_segment = false;
         }

         m4_DEBUG7('route_update_stitch',
                   '/ rt.rsteps.len:', rt.rsteps.length,
                   '/ rt.rstops.len:', rt.rstops.length,
                   '/ rt.rsn_len:', rt.rsn_len,
                   '/ new_steps.len:', new_steps.length,
                   '/ new_stops.len:', new_stops.length,
                   '/ new_rsn_len:', new_rsn_len);
         rt.rsteps = new_steps;
         rt.xs = new_xs;
         rt.ys = new_ys;
         rt.rstops = new_stops;
         rt.rsn_len = new_rsn_len;

         rt.update_route_stats();
         // Remake the edit_stops list and clear all rt_stop.dirty_stop.
         rt.rstops_sync();
         if (rt.is_drawable) {
            rt.draw();
         }
      }

      //
      protected static function rstop_index_search(rt:Route,
                                                   mx:Number,
                                                   my:Number)
         :int
      {
         var i:int;
         var dist:Number;
         var i_best:int;
         var dist_best:Number;

         var w1:Route_Stop;
         var w2:Route_Stop;

         m4_ASSERT_SOFT(rt.edit_stops.length >= 2);

         i_best = -1;
         dist_best = Infinity;
         for (i = 0; i < rt.edit_stops.length - 1; i++) {
            w1 = rt.edit_stops[i];
            w2 = rt.edit_stops[i + 1];
            dist = Geometry.distance_point_line(mx, my,
                                                w1.x_map, w1.y_map,
                                                w2.x_map, w2.y_map);
            if (dist < dist_best) {
               i_best = i;
               dist_best = dist;
            }
         }

         // check end points too
         w1 = rt.edit_stops[0];
         dist = Geometry.distance(mx, my, w1.x_map, w1.y_map);
         if (dist < dist_best) {
            // The first route_stop is closer; the new route_stop is at the
            // head of rstops.
            dist_best = dist;
            i_best = -1;
         }

         w2 = rt.edit_stops[rt.edit_stops.length - 1];
         dist = Geometry.distance(mx, my, w2.x_map, w2.y_map);
         if (dist < dist_best) {
            // The last route_stop is closer; the new route_stop is at the
            // end of rstops.
            dist_best = dist;
            i_best = rt.edit_stops.length - 1;
         }

         return i_best + 1;
      }

      //
      public static function selected_rstops_delete(route:Route) :void
      {
         if (route !== null) {
            m4_DEBUG('selected_rstops_delete: route:', route.softstr);
            if ((route.rev_is_working) && (!route.is_multimodal)) {
               var deleted_some:Boolean = false;
               var new_rstops:Array = new Array();
               for (var i:int = 0; i < route.edit_stops.length; i++) {
                  var rt_stop:Route_Stop = (route.edit_stops[i] as Route_Stop);
                  if (rt_stop.rstop_selected) {
                     if (route.num_dests <= 2) {
                        m4_WARNING('selected_rstops_delete: ran out of dests');
                        m4_ASSERT_SOFT(false);
                        break;
                     }
                     m4_DEBUG('selected_rstops_delete: rt_stop:', rt_stop);
                     if (rt_stop.parent !== null) {
                        rt_stop.parent.removeChild(rt_stop);
                     }
                     m4_TALKY('selected_rs_del: bump vers: rt_stop:', rt_stop);
                     rt_stop.stop_version += 1;
                     rt_stop.dirty_stop = true;
                     deleted_some = true;
                  }
                  else {
                     new_rstops.push(rt_stop);
                  }
               }
               if (deleted_some) {
                  route.edit_stops_set(new_rstops);
                  Route_Editor_UI.route_update(route);
               }
               route.disable_rstop_editing();
               route.route_panel.tab_route_details.on_add_dest_link_click(
                                                   /*disable_only=*/true);
            }
         }
         m4_ASSERT_ELSE_SOFT;
      }

   }
}


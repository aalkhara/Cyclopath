#!/usr/bin/python

# Copyright (c) 2006-2013 Regents of the University of Minnesota.
# For licensing terms, see the file LICENSE.

# Usage:
#
#  $ cd mapserver
#  $ ./flashclient_classes.py
#  $ ls -la ../flashclient/assets/skins
#

script_name = ('Generate flashclient/assets/skins/*.as')
script_version = '1.0'

__version__ = script_version
__author__ = 'Cyclopath <info@cyclopath.org>'
__date__ = '2013-05-06'

import re

# SYNC_ME: Search: Scripts: Load pyserver.
import os
import sys
# Setup our paths before calling pyserver_glue, which calls os.chdir.
path_to_source_skins = os.path.abspath(
   '%s/skins' % (os.path.abspath(os.curdir),))
path_to_final_skins = os.path.abspath(
   '%s/../flashclient/assets/skins' % (os.path.abspath(os.curdir),))
# Now load pyserver_glue.
sys.path.insert(0, os.path.abspath('%s/../scripts/util'
                % (os.path.abspath(os.curdir),)))
import pyserver_glue

import conf
import g

# *** Module globals
# FIXME: Make sure this always comes before other Ccp imports
import logging
from util_ import logging2
from util_.console import Console
log_level = logging.DEBUG
log_level = logging2.VERBOSE2
log_level = logging2.VERBOSE4
#log_level = logging2.VERBOSE
conf.init_logging(True, True, Console.getTerminalSize()[0]-1, log_level)

log = g.log.getLogger('fcli_classes')

from item.util.item_type import Item_Type
from skins.tile_skin import Tile_Skin
from util_ import db_glue
from util_ import misc
from util_.mod_loader import Mod_Loader

# ***

actionscript_template = (
"""/* Copyright (c) 2006-2013 Regents of the University of Minnesota.
   For licensing terms, see the file LICENSE. */

/* This file is AUTO-GENERATED. Please DO NOT EDIT THIS FILE.

   See the script: mapserver/flashclient_classes.py

   */

package assets.skins {

   //import flash.utils.Dictionary;

   public class %(class_name)s extends Tile_Skin {

      // *** Class attributes

      // NOTE: These are sorted by key_rank.
      public static const attr_keys:Object = {
%(attr_keys)s

      };

      public static const attr_pens:Object = {
%(attr_pens)s

      };

      public static const feat_pens:Object = {
%(feat_pens)s

      };

      // *** Constructor

      public function %(class_name)s() :void
      {
         m4_ASSERT(false); // Not instantiable
      }

   }
}

""")

# ***

class Flashclient_Classes(object):

   # ***

   def __init__(self):
      pass

   # ***

   #
   def go(self):
      
      log.info('Going!')

      self.setup_dest()

      self.crawl_srcs()

   #
   def setup_dest(self):

      if not os.path.exists(path_to_final_skins):
         log.debug('Making path_to_final_skins: %s' % (path_to_final_skins,))
         os.makedirs(path_to_final_skins, 02775)
      else:
         log.debug('path_to_final_skins exists: %s' % (path_to_final_skins,))
         g.assurt(os.path.isdir(path_to_final_skins))
      os.chmod(path_to_final_skins, 02775)

   #
   def crawl_srcs(self):

      for skin_path in os.listdir(path_to_source_skins):
         if (skin_path.startswith('skin_')
             and skin_path.endswith('.py')):
            log.debug('Processing skin: %s' % (skin_path,))
            self.crawl_skin(skin_path)
         else:
            log.debug('Ignoring non-skin: %s' % (skin_path,))

   #
   def crawl_skin(self, skin_path):

      # Get the skin_name from the skin_path, which is a Python module.
      skin_name = re.sub(r'\.py$', '', skin_path)

      # Load the skin file.
      tile_skin = self.get_tile_skin(skin_name, skin_path)

      # Make the class name: just uppercase around underscores.
      # FUNNY: Why not just: [x.capitalize() for x in skin_name.split('_')]
      class_names = [x[0].upper() + x[1:] for x in skin_name.split('_')]
      class_name = '_'.join(class_names)

      tmpl_args = {}
      tmpl_args['class_name'] = class_name
      tmpl_args['attr_keys'] = self.get_attr_keys(tile_skin)
      tmpl_args['attr_pens'] = self.get_attr_pens(tile_skin)
      tmpl_args['feat_pens'] = self.get_feat_pens(tile_skin)

      # Open the destination file.
      skin_filename = '%s.as' % (class_name,)
      output_path = os.path.join(path_to_final_skins, skin_filename)

      # Finally, write the file using the string template.
      new_f = open(output_path, 'w')
      new_f.write(actionscript_template % tmpl_args)
      new_f.close()
      os.chmod(output_path, 0664)

   #
   def get_tile_skin(self, skin_name, skin_path):

      source_path = os.path.join(path_to_source_skins, skin_path)

      # This is a little bit C.f. tilecache_update.get_tile_skin.

      module_path = ('skins.%s' % (skin_name,))
      skin_module = Mod_Loader.load_package_module(module_path)

      tile_skin = skin_module.get_skin()
      g.assurt(tile_skin is not None)

      log.debug('Loaded skin: %s' % (skin_name,))

      return tile_skin

   #
   def get_attr_keys(self, tile_skin):

      attr_keys = []

      #for attr_name, key_pens in tile_skin.attr_pens.iteritems():
      attrs_names = tile_skin.attr_pens.keys()
      attrs_names.sort()
      for attr_name in attrs_names:
         key_pens = tile_skin.attr_pens[attr_name]

         key_names = []
         #for attr_key, attr_pen in key_pens.iteritems():
         attrs_keys = key_pens.keys()
         # Rather than sort alphabetically, sort by rank.
         # Alphabetical: attrs_keys.sort()
         # Sort by key rank:
         attrs_keys.sort(key=lambda x: key_pens[x].key_rank)
         for attr_key in attrs_keys:
            attr_pen = key_pens[attr_key]

            key_names.append("'%s'" % (attr_key,))
         attr_keys.append(
               """
         '%s': [
            %s,
            ]""" % (attr_name,
                  ',\n            '.join(key_names),))
      # end: outer for
      return ',\n'.join(attr_keys)

   #
   def get_attr_pens(self, tile_skin):

      attr_pens = []

      #for attr_name, key_pens in tile_skin.attr_pens.iteritems():
      attrs_names = tile_skin.attr_pens.keys()
      attrs_names.sort()
      for attr_name in attrs_names:
         key_pens = tile_skin.attr_pens[attr_name]

         pen_keys = []

         #for attr_key, attr_pen in key_pens.iteritems():
         attrs_keys = key_pens.keys()
         attrs_keys.sort()
         for attr_key in attrs_keys:
            attr_pen = key_pens[attr_key]

            dashon_color = misc.color_str_dec_to_hex(attr_pen.dashon_color)
            nodash_color = misc.color_str_dec_to_hex(attr_pen.nodash_color)
            gut_on_color = misc.color_str_dec_to_hex(attr_pen.gut_on_color)
            no_gut_color = misc.color_str_dec_to_hex(attr_pen.no_gut_color)
            pen_keys.append(
               """
            '%s': {
               'attr_name': '%s',
               'attr_key': '%s',
               'key_rank': %s,
               'key_friendly': '%s',
               'icon_class': '%s',
               'dashon_color': %s,
               'nodash_color': %s,
               'dashon_interval': %d,
               'nodash_interval': %d,
               'interval_square': %s,
               'gut_width': %d,
               'gut_on_color': %s,
               'no_gut_color': %s,
               'gut_on_interval': %d,
               'no_gut_interval': %d
            }""" % (attr_key,
                    attr_pen.attr_name,
                    attr_pen.attr_key,
                    attr_pen.key_rank,
                    attr_pen.key_friendly,
                    attr_pen.icon_class,
                    dashon_color if dashon_color is not None else 'null',
                    nodash_color if nodash_color is not None else 'null',
                    attr_pen.dashon_interval,
                    attr_pen.nodash_interval,
                    'true' if attr_pen.interval_square else 'false',
                    attr_pen.gut_width,
                    gut_on_color if gut_on_color is not None else 'null',
                    no_gut_color if no_gut_color is not None else 'null',
                    attr_pen.gut_on_interval,
                    attr_pen.no_gut_interval,
                    ))
         # end: inner for
         attr_pens.append(
               """
         '%s': {
            %s
         }""" % (attr_name,
                 ',\n'.join(pen_keys),))
      # end: outer for
      return ',\n'.join(attr_pens)

   #
   def get_feat_pens(self, tile_skin):

      feat_pens = []

      # for gfl_id in tile_skin.gfls_deffed:
      #for gfl_id, feat_pen in tile_skin.feat_pens.iteritems():
      gfls_ids = tile_skin.feat_pens.keys()
      gfls_ids.sort()
      for gfl_id in gfls_ids:
         feat_pen = tile_skin.feat_pens[gfl_id]

         pen_color = misc.color_str_dec_to_hex(feat_pen.pen_color)
         shadow_color = misc.color_str_dec_to_hex(feat_pen.shadow_color)
         label_color = misc.color_str_dec_to_hex(feat_pen.label_color)
         labelo_color = misc.color_str_dec_to_hex(feat_pen.labelo_color)
         feat_pens.append(
            """
         '%s': {
            'restrict_usage': %s,
            'friendly_name': '%s',
            'pen_color': %s,
            'shadow_width': %s,
            'shadow_color': %s,
            'label_color': %s,
            'labelo_width': %s,
            'labelo_color': %s,
            'tile_pens' : {%s}}"""
            % (gfl_id,
               'true' if feat_pen.restrict_usage else 'false',
               feat_pen.friendly_name,
               pen_color if pen_color is not None else 'null',
               feat_pen.shadow_width,
               shadow_color if shadow_color is not None else 'null',
               label_color if label_color is not None else 'null',
               feat_pen.labelo_width,
               labelo_color if labelo_color is not None else 'null',
               self.get_tile_pens(tile_skin, gfl_id),
               ))
      return ','.join(feat_pens)

   #
   def get_tile_pens(self, tile_skin, gfl_id):

      tile_pens = []

      try:

         # for gfl_id in tile_skin.gfls_deffed:
         #for zoom_level, tile_pen in tile_skin.tile_pens[gfl_id].iteritems():
         zooms_levels = tile_skin.tile_pens[gfl_id].keys()
         zooms_levels.sort()
         for zoom_level in zooms_levels:
            tile_pen = tile_skin.tile_pens[gfl_id][zoom_level]

            g.assurt(zoom_level == tile_pen.zoom_level)
            tile_pens.append(
               """
               '%s': {
                  'zoom_level': %s,
                  'do_draw': %s,
                  'pen_gutter': %s,
                  'pen_width': %s,
                  'do_label': %s,
                  'label_size': %s}"""
                  % (zoom_level,
                     tile_pen.zoom_level,
                     'true' if tile_pen.do_draw else 'false',
                     tile_pen.pen_gutter,
                     tile_pen.pen_width,
                     'true' if tile_pen.do_label else 'false',
                     tile_pen.label_size,
                     ))
      except KeyError:
         # The gfl_id has no tile_pens. This is for some things we don't
         # currently label, like terrain.
         pass
      return ','.join(tile_pens)

   # ***

# ***

if (__name__ == '__main__'):
   fccls = Flashclient_Classes()
   fccls.go()


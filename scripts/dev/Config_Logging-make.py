#!/usr/bin/python

# Copyright (c) 2006-2013 Regents of the University of Minnesota.
# For licensing terms, see the file LICENSE.

# Usage:
#
#  $ cd scripts/dev
#  $ ./Config_Logging-make.py
#  $ meld ../../flashclient/Config_Logging.as ./Config_Logging.as
#

# FIXME: There are a number of loggers (a) whose name > 12 chars
#                                  and (b) missing from files.

script_name = ('Generate Config_Logging.as')
script_version = '1.0'

__version__ = script_version
__author__ = 'Cyclopath <info@cyclopath.org>'
__date__ = '2011-12-10'

import datetime
import re

# SYNC_ME: Search: Scripts: Load pyserver.
import os
import sys
# Setup our paths before calling pyserver_glue, which calls os.chdir.
path_to_new_file = os.path.abspath(
   '%s/Config_Logging.as' % (os.path.abspath(os.curdir),))
path_to_flashclient = os.path.abspath(
   '%s/../../flashclient' % (os.path.abspath(os.curdir),))
# Now load pyserver_glue.
sys.path.insert(0, os.path.abspath('%s/../util'
                % (os.path.abspath(os.curdir),)))
import pyserver_glue

import conf
import g

# *** Module globals
# FIXME: Make sure this always comes before other Ccp imports
import logging
from util_ import logging2
from util_.console import Console
log_level = logging.DEBUG
log_level = logging2.VERBOSE2
log_level = logging2.VERBOSE4
#log_level = logging2.VERBOSE
conf.init_logging(True, True, Console.getTerminalSize()[0]-1, log_level)

log = g.log.getLogger('cfg_loggg_mk')

from grax.access_level import Access_Level
from gwis.query_branch import Query_Branch
from item import item_base
from item import link_value
from item.attc import attribute
from item.feat import branch
from item.feat import byway
from item.feat import route
from item.grac import group
from item.link import link_attribute
from item.link import link_tag
from item.util import ratings
from item.util import revision
from item.util.item_type import Item_Type
from util_ import db_glue
from util_ import geometry
from util_ import gml

# ***

actionscript_header = (
"""/* Copyright (c) 2006-%d Regents of the University of Minnesota.
   For licensing terms, see the file LICENSE. */

/* This file is AUTO-GENERATED. Please DO NOT EDIT THIS FILE.

   See the script: scripts/dev/Config_Logging-make.py

   */

package {

   public class Config_Logging {

      // *** Static class variables

      // Flex doesn't support inline Dictionary definition, e.g., foo = {},
      // so using an array of arrays.
      public static const debug_logging_levels:Array =
         [
            //
            ['root'        , 'DEBUG' ],
            // System-wide loggers
            ['==TIME.IT==' , 'DEBUG' ],
            ['=CALLLATER=' , 'DEBUG' ],
            //
            // Bug nnnn: Let user specify the debug level in the file itself.
            // Not sure if this value would override the file herein or not.
            //
""" % (datetime.date.today().year,))

actionscript_footer = (
"""         ];

   }
}

""")

# ***

class Config_Logging__make(object):

   flex_source_exts = ('.as', '.mxml',)

   # ***

   def __init__(self):
      self.file_counts = {}
      self.file_counts['total'] = 0
      for ext in Config_Logging__make.flex_source_exts:
         self.file_counts[ext] = 0
      self.by_scope = {}
      self.by_scope['missing'] = list()
      self.by_scope['duplicate'] = set()
      self.by_scope['public'] = list()
      self.by_scope['protected'] = list()
      self.by_scope['private'] = list()
      self.by_str_len = {}
      self.loggr_names = {}
      self.by_pathname = {}

   # ***

   #
   def go(self):
      self.crawl()
      self.report()
      self.make_file()

   # ***

   #
   def crawl(self):
      log.info('going!')
      log.debug(' >> path_to_flashclient: %s' % (path_to_flashclient,))
      path_to_build_dir_all = path_to_flashclient + '/build'
      path_to_build_dir_part = path_to_flashclient + '/build/'
      for dirpath, dirnames, filenames in os.walk(path_to_flashclient,
                                                  topdown=False):
         log.verbose(' >> dirpath: %s' % dirpath)
         log.verbose(' >> dirnames: %s' % dirnames)
         log.verbose(' >> filenames: %s' % filenames)
         # We get all the filenames from all the subdirs in filenames, so we
         # can ignore dirnames. We use dirpath to rebuild the full to the file.
         for fname in filenames:
            is_source = False
            log.verbose('dirpath: %s / fname: %s' % (dirpath, fname,))
            if ((dirpath == path_to_build_dir_all)
                or (dirpath.startswith(path_to_build_dir_part))):
               log.verbose('Ignoring build directory file.')
               continue
            for ext in Config_Logging__make.flex_source_exts:
               if fname.endswith(ext):
                  self.file_counts['total'] += 1
                  self.file_counts[ext] += 1
                  is_source = True
                  break
            if is_source:
               pathname = os.path.join(dirpath, fname)
               self.parse_src(pathname)

   # ***

   logger_re_line = (
      re.compile(r"^\s*(p[a-z]+) static var log:Logging = "
                 + r"Logging.get_logger\('([^']+)'\);.*$"))
   logger_re_file = re.compile(r'FIXME.+\n.+\s(/gwis.+)\s.+\n\n.+\n\n(.*)',
                               re.DOTALL)

   parse_style = 'lines'
   #parse_style = 'files'

   # See below for code to help test.

   #
   def parse_src(self, pathname):
      #log.debug('parse_src: pathname: %s' % pathname)
      src_f = open(pathname, 'r')
      m = None
      if Config_Logging__make.parse_style == 'lines':
         for ln in src_f:
            m = Config_Logging__make.logger_re_line.match(ln)
            if (m is not None):
               break
      elif Config_Logging__make.parse_style == 'files':
         m = Config_Logging__make.logger_re_file.match(src_f.read())
      else:
         g.assurt(False)
      if m is not None:
         # m.group(0) is the whole line either with or without the newline (the
         # latter if not re.DOTALL).
         lggr_scope = m.group(1)
         lggr_name = m.group(2)
         #log.debug(' >> logger: %12s / scope: %9s' % (lggr_name, lggr_scope,))
         if lggr_name in self.loggr_names:
            log.verbose('Duplicate logger name?: %s / for: %s / exists: %s'
                        % (lggr_name, pathname, self.loggr_names[lggr_name],))
            self.by_scope['duplicate'].add(pathname)
            self.by_scope['duplicate'].add(self.loggr_names[lggr_name])
         # Remember by scope
         try:
            self.by_scope[lggr_scope].append(pathname)
         except KeyError:
            log.warning('Unknown scope! "%s" for file "%s"'
                        % (lggr_scope, pathname,))
         # Remember by string length
         str_len = len(lggr_name)
         self.by_str_len.setdefault(str_len, list())
         self.by_str_len[str_len].append(pathname)
         # Remember the logger name
         self.loggr_names[lggr_name] = pathname
         self.by_pathname[pathname] = lggr_name
      else:
         log.verbose(' >> no logger for: %s' % (pathname,))
         self.by_scope['missing'].append(pathname)

      src_f.close()

   # ***

   #
   def report(self):
      # All the logger names
      loggr_names_ordered = self.loggr_names.keys()
      loggr_names_ordered.sort()
      log.info('Total logger names: %4d' % (len(loggr_names_ordered),))
      log.info('All the Logger names: %s' % (loggr_names_ordered,))
      # By file extension type
      log.info('Total source files: %04d' % (self.file_counts['total'],))
      for ext in Config_Logging__make.flex_source_exts:
         log.info('  >> of type %5s: %04d' % (ext, self.file_counts[ext],))
      # By scope, or if missing completely
      log.info('String length counts:')
      log.info('  >>    public: %04d' % (len(self.by_scope['public']),))
      log.info('  >> protected: %04d' % (len(self.by_scope['protected']),))
      log.info('  >>   private: %04d' % (len(self.by_scope['private']),))
      log.info('  >>   missing: %04d' % (len(self.by_scope['missing']),))
      log.info('  >> duplicate: %04d' % (len(self.by_scope['duplicate']),))
      # By logger name length
      str_len_ordered = self.by_str_len.keys()
      str_len_ordered.sort()
      log.info('String length counts:')
      for str_len in str_len_ordered:
         log.info('  >> of len %2d: %04d'
                  % (str_len, len(self.by_str_len[str_len]),))
      # Short or long logger names
      log.info('Abnormal length logger names:')
      for str_len in str_len_ordered:
         if ((str_len < 5) or (str_len > 12)):
            for pathname in self.by_str_len[str_len]:
               log.info('  >> len: %2d / %s / %s'
                        % (str_len, self.by_pathname[pathname], pathname,))
      # Duplicate logger names
      if self.by_scope['duplicate']:
         log.info('Duplicate logger names:')
         for pathname in self.by_scope['duplicate']:
            log.info('  >> %s / %s' % (self.by_pathname[pathname], pathname,))
      # Files missing logger names
      if self.by_scope['missing']:
         log.info('Files lacking logger names:')
         for pathname in self.by_scope['missing']:
            log.info('  >> %s' % (pathname,))

   # ***

   #
   def make_file(self):
      loggr_names_ordered = self.loggr_names.keys()
      loggr_names_ordered.sort()
      new_f = open(path_to_new_file, 'w')
      new_f.write(actionscript_header)
      for lggr_name in loggr_names_ordered:
         spaces = ' ' * (12 - len(lggr_name))
         new_line = "            ['%s'%s, 'DEBUG' ],\n" % (lggr_name, spaces,)
         new_f.write(new_line)
      new_f.write(actionscript_footer)
      new_f.close()

# ***

if (__name__ == '__main__'):
   cfm = Config_Logging__make()
   cfm.go()

# *** Sandbox for regex testing.

sys.exit(0)

import re
m = re.match(r"^\s*(p[a-z]+) static var log:Logging = ", "public static var log:Logging = ") ; print m
m = re.match(r"Logging.get_logger\('([^']+)'\);", "Logging.get_logger('asdsdf');") ; print m
ln1 = "      protected static var log:Logging = Logging.get_logger('~GW/Q_Filts');\n"
ln2 = 'public function update_working_copy() :void\n'
ln3 = "public static var log:Logging = Logging.get_logger('asdsdf');"
rel = (
   r"^\s*(p[a-z]+) static var log:Logging = "
   + r"Logging.get_logger\('([^']+)'\);.*$")

m = re.match(rel, ln1) ; print m
# >>> m.group(0)
# "      protected static var log:Logging = Logging.get_logger('~GW/Q_Filts');"
# >>> m.group(1)
# 'protected'
# >>> m.group(2)
# '~GW/Q_Filts'

m = re.match(rel, ln1, re.DOTALL) ; print m
# >>> m.group(0)
# "      protected static var log:Logging = Logging.get_logger('~GW/Q_Filts');\n"
# >>> m.group(1)
# 'protected'
# >>> m.group(2)
# '~GW/Q_Filts'

m = re.match(rel, ln2) ; print m
m = re.match(rel, ln3) ; print m

